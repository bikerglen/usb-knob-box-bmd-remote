C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE EFM8_USBDCH9
OBJECT MODULE PLACED IN .\lib\efm8_usb\src\efm8_usbdch9.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\SiliconLabs\S
                    -implicityStudio\v4\developer\sdks\8051\v4.1.7\Lib\efm8_usb\src\efm8_usbdch9.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) W
                    -ARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\glen\SimplicityStudio\v4_wor
                    -kspace\EFM8UB2_HID_VendorDefined_Knobs_01\inc;C:\Users\glen\SimplicityStudio\v4_workspace\EFM8UB2_HID_VendorDefined_Knob
                    -s_01\inc\config;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//kits/EFM8UB2_SLSTK2001A/config;C:/Silicon
                    -Labs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Lib/efm8_assert;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8
                    -051/v4.1.7//Lib/efm8_usb/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//Device/EFM8UB2/peripheral_dr
                    -iver/inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//kits/common/bsp;C:/SiliconLabs/SimplicityStudio/
                    -v4/developer/sdks/8051/v4.1.7//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.7//D
                    -evice/EFM8UB2/inc) REGFILE(EFM8UB2_HID_VendorDefined_Knobs_01.ORC) PRINT(.\lib\efm8_usb\src\efm8_usbdch9.lst) COND PAGEW
                    -IDTH(120) PAGELENGTH(65) OBJECT(.\lib\efm8_usb\src\efm8_usbdch9.OBJ)

line level    source

   1          /**************************************************************************//**
   2           * Copyright (c) 2015 by Silicon Laboratories Inc. All rights reserved.
   3           *
   4           * http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   5           *****************************************************************************/
   6          
   7          #include "si_toolchain.h"
   8          #include "efm8_usb.h"
   9          #include <stdint.h>
  10          #include <endian.h>
  11          
  12          // -----------------------------------------------------------------------------
  13          // Function Prototypes
  14          
  15          static USB_Status_TypeDef ClearFeature(void);
  16          static USB_Status_TypeDef GetConfiguration(void);
  17          static USB_Status_TypeDef GetDescriptor(void);
  18          static USB_Status_TypeDef GetInterface(void);
  19          static USB_Status_TypeDef GetStatus(void);
  20          static USB_Status_TypeDef SetAddress(void);
  21          static USB_Status_TypeDef SetConfiguration(void);
  22          static USB_Status_TypeDef SetFeature(void);
  23          static USB_Status_TypeDef SetInterface(void);
  24          static void USBD_ActivateAllEps(bool forceIdle);
  25          static void EP0_Write(SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_GENERIC), uint16_t numBytes);
  26          
  27          // -----------------------------------------------------------------------------
  28          // Global Variables
  29          
  30          extern SI_SEGMENT_VARIABLE(myUsbDevice, USBD_Device_TypeDef, MEM_MODEL_SEG);
  31          const SI_SEGMENT_VARIABLE(txZero[2], uint8_t, SI_SEG_CODE);
  32          
  33          // -----------------------------------------------------------------------------
  34          // Static Global Variables
  35          
  36          static uint16_t pStatus;
  37          
  38          // -----------------------------------------------------------------------------
  39          // Chapter 9 Functions
  40          
  41          /***************************************************************************//**
  42           * @brief       Processes Standard Request (Chapter 9 Command)
  43           * @return      Status of request (type @ref USB_Status_TypeDef)
  44           * @note        This function takes no parameters, but it uses the setup command
  45           *              stored in @ref myUsbDevice.setup.
  46           ******************************************************************************/
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 2   

  47          USB_Status_TypeDef USBDCH9_SetupCmd(void)
  48          {
  49   1        USB_Status_TypeDef status = USB_STATUS_OK;
  50   1      
  51   1        switch (myUsbDevice.setup.bRequest)
  52   1        {
  53   2          case GET_STATUS:
  54   2            status = GetStatus();
  55   2            break;
  56   2      
  57   2          case CLEAR_FEATURE:
  58   2            status = ClearFeature();
  59   2            break;
  60   2      
  61   2          case SET_FEATURE:
  62   2            status = SetFeature();
  63   2            break;
  64   2      
  65   2          case SET_ADDRESS:
  66   2            status = SetAddress();
  67   2            break;
  68   2      
  69   2          case GET_DESCRIPTOR:
  70   2            status = GetDescriptor();
  71   2            break;
  72   2      
  73   2          case GET_CONFIGURATION:
  74   2            status = GetConfiguration();
  75   2            break;
  76   2      
  77   2          case SET_CONFIGURATION:
  78   2            status = SetConfiguration();
  79   2            break;
  80   2      
  81   2          case GET_INTERFACE:
  82   2            status = GetInterface();
  83   2            break;
  84   2      
  85   2          case SET_INTERFACE:
  86   2            status = SetInterface();
  87   2            break;
  88   2      
  89   2          default:
  90   2            status = USB_STATUS_REQ_ERR;
  91   2            break;
  92   2        }
  93   1      
  94   1        return status;
  95   1      }
  96          
  97          /***************************************************************************//**
  98           * @brief       Clears the requested feature
  99           * @details     Supports CLEAR_FEATURE for Remote Wakeup and Endpoint Halt
 100           * @return      Status of request (type @ref USB_Status_TypeDef)
 101           * @note        This function takes no parameters, but it uses the setup command
 102           *              stored in @ref myUsbDevice.setup.
 103           ******************************************************************************/
 104          static USB_Status_TypeDef ClearFeature(void)
 105          {
 106   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 107   1      
 108   1        if (myUsbDevice.setup.wLength == 0)
 109   1        {
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 3   

 110   2          switch (myUsbDevice.setup.bmRequestType.Recipient)
 111   2          {
 112   3        #if SLAB_USB_REMOTE_WAKEUP_ENABLED
                    case USB_SETUP_RECIPIENT_DEVICE:
                      if ((myUsbDevice.setup.wIndex == 0)
                          && (myUsbDevice.setup.wValue == USB_FEATURE_DEVICE_REMOTE_WAKEUP)
                          && (myUsbDevice.state >= USBD_STATE_ADDRESSED))
                      {
                        // Remote wakeup feature clear
                        myUsbDevice.remoteWakeupEnabled = false;
                        retVal = USB_STATUS_OK;
                      }
                      break;
                #endif // SLAB_USB_REMOTE_WAKEUP_ENABLED
 124   3            case USB_SETUP_RECIPIENT_ENDPOINT:
 125   3              if (myUsbDevice.setup.wValue == USB_FEATURE_ENDPOINT_HALT)
 126   3              {
 127   4                // Device does not support halting endpoint 0, but do not return
 128   4                // an error as this is a valid request
 129   4                if (((myUsbDevice.setup.wIndex & ~USB_EP_DIR_IN) == 0)
 130   4                    && (myUsbDevice.state >= USBD_STATE_ADDRESSED))
 131   4                {
 132   5                  retVal = USB_STATUS_OK;
 133   5                }
 134   4                else if (((myUsbDevice.setup.wIndex & ~USB_SETUP_DIR_D2H) < SLAB_USB_NUM_EPS_USED)
 135   4                         && (myUsbDevice.state == USBD_STATE_CONFIGURED))
 136   4                {
 137   5                  retVal = USB_STATUS_OK;
 138   5                  USB_SetIndex((myUsbDevice.setup.wIndex & 0xFF) & ~USB_SETUP_DIR_D2H);
 139   5      
 140   5      #if (SLAB_USB_EP1IN_USED || SLAB_USB_EP2IN_USED || SLAB_USB_EP3IN_USED)
 141   5                  if ((myUsbDevice.setup.wIndex & 0xFF) & USB_EP_DIR_IN)
 142   5                  {
 143   6                    USB_EpnInEndStallAndClearDataToggle();
 144   6                  }
 145   5      #endif
 146   5      #if (SLAB_USB_EP1OUT_USED || SLAB_USB_EP2OUT_USED || SLAB_USB_EP3OUT_USED)
 147   5                  if (((myUsbDevice.setup.wIndex & 0xFF) & USB_EP_DIR_IN) == 0)
 148   5                  {
 149   6                    USB_EpnOutEndStallAndClearDataToggle();
 150   6                  }
 151   5      #endif
 152   5      
 153   5                  switch (myUsbDevice.setup.wIndex & 0xFF)
 154   5                  {
 155   6      #if SLAB_USB_EP1OUT_USED
 156   6                    case (USB_EP_DIR_OUT | 1):
 157   6                      if (myUsbDevice.ep1out.state != D_EP_RECEIVING)
 158   6                      {
 159   7                        myUsbDevice.ep1out.state = D_EP_IDLE;
 160   7                      }
 161   6                      break;
 162   6      #endif
 163   6      #if SLAB_USB_EP2OUT_USED
                            case (USB_EP_DIR_OUT | 2):
                              if (myUsbDevice.ep2out.state != D_EP_RECEIVING)
                              {
                                myUsbDevice.ep2out.state = D_EP_IDLE;
                              }
                              break;
              #endif
 171   6      #if SLAB_USB_EP3OUT_USED
                            case (USB_EP_DIR_OUT | 3):
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 4   

                              if (myUsbDevice.ep3out.state != D_EP_RECEIVING)
                              {
                                myUsbDevice.ep3out.state = D_EP_IDLE;
                              }
                              break;
              #endif
 179   6      #if SLAB_USB_EP1IN_USED
 180   6                    case (USB_EP_DIR_IN | 1):
 181   6                      if (myUsbDevice.ep1in.state != D_EP_TRANSMITTING)
 182   6                      {
 183   7                        myUsbDevice.ep1in.state = D_EP_IDLE;
 184   7                      }
 185   6                      break;
 186   6      #endif
 187   6      #if SLAB_USB_EP2IN_USED
                            case (USB_EP_DIR_IN | 2):
                              if (myUsbDevice.ep2in.state != D_EP_TRANSMITTING)
                              {
                                myUsbDevice.ep2in.state = D_EP_IDLE;
                              }
                              break;
              #endif
 195   6      #if SLAB_USB_EP3IN_USED
                            case (USB_EP_DIR_IN | 3):
                              if (myUsbDevice.ep3in.state != D_EP_TRANSMITTING)
                              {
                                myUsbDevice.ep3in.state = D_EP_IDLE;
                              }
                              break;
              #endif
 203   6                  }
 204   5                }
 205   4              }
 206   3          }
 207   2        }
 208   1        return retVal;
 209   1      }
 210          
 211          /***************************************************************************//**
 212           * @brief       Gets the current configuration value
 213           * @details     Zero means the device is not configured, a non-zero value
 214           *              is the configuration value of the configured device.
 215           * @return      Status of request (type @ref USB_Status_TypeDef)
 216           * @note        This function takes no parameters, but it uses the setup command
 217           *              stored in @ref myUsbDevice.setup.
 218           ******************************************************************************/
 219          static USB_Status_TypeDef GetConfiguration(void)
 220          {
 221   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 222   1      
 223   1        if ((myUsbDevice.setup.wIndex == 0)
 224   1            && (myUsbDevice.setup.wValue == 0)
 225   1            && (myUsbDevice.setup.wLength == 1)
 226   1            && (myUsbDevice.setup.bmRequestType.Direction == USB_SETUP_DIR_IN)
 227   1            && (myUsbDevice.setup.bmRequestType.Recipient == USB_SETUP_RECIPIENT_DEVICE))
 228   1        {
 229   2          if (myUsbDevice.state == USBD_STATE_ADDRESSED)
 230   2          {
 231   3            EP0_Write((SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))txZero, 1);
 232   3            retVal = USB_STATUS_OK;
 233   3          }
 234   2          else if (myUsbDevice.state == USBD_STATE_CONFIGURED)
 235   2          {
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 5   

 236   3            EP0_Write(&myUsbDevice.configurationValue, 1);
 237   3            retVal = USB_STATUS_OK;
 238   3          }
 239   2        }
 240   1        return retVal;
 241   1      }
 242          
 243          /***************************************************************************//**
 244           * @brief       Sends the requested USB Descriptor
 245           * @details     Supports single or multiple languages (configured by
 246           *              @ref SLAB_USB_NUM_LANGUAGES).
 247           * @return      Status of request (type @ref USB_Status_TypeDef)
 248           * @note        This function takes no parameters, but it uses the setup command
 249           *              stored in @ref myUsbDevice.setup.
 250           ******************************************************************************/
 251          static USB_Status_TypeDef GetDescriptor(void)
 252          {
 253   1      #if (SLAB_USB_NUM_LANGUAGES > 1)
                bool langSupported;
                uint8_t lang;
              #endif
 257   1      
 258   1        uint8_t index;
 259   1        uint16_t length = 0;
 260   1        SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_GENERIC);
 261   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 262   1      
 263   1        if (*((uint8_t *)&myUsbDevice.setup.bmRequestType) ==
 264   1            (USB_SETUP_DIR_D2H | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE))
 265   1        {
 266   2          index = myUsbDevice.setup.wValue & 0xFF;
 267   2      
 268   2          switch (myUsbDevice.setup.wValue >> 8)
 269   2          {
 270   3            case USB_DEVICE_DESCRIPTOR:
 271   3              if (index != 0)
 272   3              {
 273   4                break;
 274   4              }
 275   3              dat = (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))myUsbDevice.deviceDescriptor;
 276   3              length = myUsbDevice.deviceDescriptor->bLength;
 277   3              break;
 278   3      
 279   3            case USB_CONFIG_DESCRIPTOR:
 280   3              if (index != 0)
 281   3              {
 282   4                break;
 283   4              }
 284   3              dat = (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))myUsbDevice.configDescriptor;
 285   3              length = le16toh(myUsbDevice.configDescriptor->wTotalLength);
 286   3              break;
 287   3      
 288   3            case USB_STRING_DESCRIPTOR:
 289   3        #if (SLAB_USB_NUM_LANGUAGES == 1)
 290   3      
 291   3              dat = (SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))myUsbDevice.stringDescriptors[index]
             -;
 292   3      
 293   3              // Index 0 is the language string. If SLAB_USB_NUM_LANGUAGES == 1, we
 294   3              // know the length will be 4 and the format will be UTF16LE.
 295   3              if (index == 0)
 296   3              {
 297   4                length = 4;
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 6   

 298   4                myUsbDevice.ep0String.encoding.type = USB_STRING_DESCRIPTOR_UTF16LE;
 299   4              }
 300   3              // Otherwise, verify the language is correct (either the value set as
 301   3              // SLAB_USB_LANGUAGE in usbconfig.h, or 0).
 302   3              else if ((myUsbDevice.setup.wIndex == 0) || (myUsbDevice.setup.wIndex == SLAB_USB_LANGUAGE))
 303   3              {
 304   4                // Verify the index is valid
 305   4                if (index < myUsbDevice.numberOfStrings)
 306   4                {
 307   5                  length = *(dat + USB_STRING_DESCRIPTOR_LENGTH);
 308   5                  myUsbDevice.ep0String.encoding.type = *(dat + USB_STRING_DESCRIPTOR_ENCODING);
 309   5                  dat += USB_STRING_DESCRIPTOR_LENGTH;
 310   5                  myUsbDevice.ep0String.encoding.init = true;
 311   5                }
 312   4              }
 313   3        #elif (SLAB_USB_NUM_LANGUAGES > 1)
              
                      langSupported = false;
              
                      // Index 0 is the language.
                      if (index == 0)
                      {
                        dat = ((SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))myUsbDevice.stringDescriptors->la
             -nguageArray[0][index]);
                        length = *((uint8_t *)dat);
                        myUsbDevice.ep0String.encoding.type = USB_STRING_DESCRIPTOR_UTF16LE;
                      }
                      else
                      {
                        // Otherwise, verify the language is one of the supported languages or 0.
                        for (lang = 0; lang < SLAB_USB_NUM_LANGUAGES; lang++)
                        {
                          if ((myUsbDevice.stringDescriptors->languageIDs[lang] == myUsbDevice.setup.wIndex)
                              || (myUsbDevice.stringDescriptors->languageIDs[lang] == 0))
                          {
                            langSupported = true;
                            break;
                          }
                        }
                        if ((langSupported == true) && (index < myUsbDevice.numberOfStrings))
                        {
                          dat = ((SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))myUsbDevice.stringDescriptors->
             -languageArray[lang][index]);
                          length = *(dat + USB_STRING_DESCRIPTOR_LENGTH);
                          myUsbDevice.ep0String.encoding.type = *(dat + USB_STRING_DESCRIPTOR_ENCODING);
                          dat += USB_STRING_DESCRIPTOR_LENGTH;
              
                          if (myUsbDevice.ep0String.encoding.type == USB_STRING_DESCRIPTOR_UTF16LE_PACKED)
                          {
                            myUsbDevice.ep0String.encoding.init = true;
                          }
                          else
                          {
                            myUsbDevice.ep0String.encoding.init = false;
                          }
                        }
                      }
                #endif // ( SLAB_USB_NUM_LANGUAGES == 1 )
 354   3          }
 355   2      
 356   2          // If there is a descriptor to send, get the proper length, then call
 357   2          // EP0_Write() to send.
 358   2          if (length)
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 7   

 359   2          {
 360   3            if (length > myUsbDevice.setup.wLength)
 361   3            {
 362   4              length = myUsbDevice.setup.wLength;
 363   4            }
 364   3      
 365   3            EP0_Write(dat, length);
 366   3      
 367   3            retVal = USB_STATUS_OK;
 368   3          }
 369   2        }
 370   1      
 371   1        return retVal;
 372   1      }
 373          
 374          /***************************************************************************//**
 375           * @brief       Sends the current interface alternate setting
 376           * @details     Sends 0x0000 if alternate interfaces are not supported.
 377           * @return      Status of request (type @ref USB_Status_TypeDef)
 378           * @note        This function takes no parameters, but it uses the setup command
 379           *              stored in @ref myUsbDevice.setup.
 380           ******************************************************************************/
 381          static USB_Status_TypeDef GetInterface(void)
 382          {
 383   1        uint16_t interface = myUsbDevice.setup.wIndex;
 384   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 385   1      
 386   1        if ((interface < SLAB_USB_NUM_INTERFACES)
 387   1            && (myUsbDevice.setup.wLength == 1)
 388   1            && (myUsbDevice.setup.wValue == 0)
 389   1            && (*((uint8_t *)&myUsbDevice.setup.bmRequestType) ==
 390   1                (USB_SETUP_DIR_D2H | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_INTERFACE)))
 391   1        {
 392   2          if (myUsbDevice.state == USBD_STATE_CONFIGURED)
 393   2          {
 394   3      #if (SLAB_USB_SUPPORT_ALT_INTERFACES)
                    // Return the alternate setting for the specified interface
                    EP0_Write((SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))&myUsbDevice.interfaceAltSetting[i
             -nterface], 1);
              #else
 398   3            // Alternate interfaces are not supported, so return 0x0000.
 399   3            EP0_Write((SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))&txZero, 1);
 400   3      #endif
 401   3            retVal = USB_STATUS_OK;
 402   3          }
 403   2        }
 404   1        return retVal;
 405   1      }
 406          
 407          /***************************************************************************//**
 408           * @brief       Sends the requested Remote Wakeup, Self-Powered, or
 409           *              Endpoint Status
 410           * @return      Status of request (type @ref USB_Status_TypeDef)
 411           * @note        This function takes no parameters, but it uses the setup command
 412           *              stored in @ref myUsbDevice.setup.
 413           ******************************************************************************/
 414          static USB_Status_TypeDef GetStatus(void)
 415          {
 416   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 417   1      
 418   1        if ((myUsbDevice.setup.wLength == 2)
 419   1            && (myUsbDevice.setup.wValue == 0)
 420   1            && (myUsbDevice.setup.bmRequestType.Direction == USB_SETUP_DIR_IN)
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 8   

 421   1            && (myUsbDevice.state >= USBD_STATE_ADDRESSED))
 422   1        {
 423   2          pStatus = htole16(0);         // Default return value is 0x0000
 424   2      
 425   2          switch (myUsbDevice.setup.bmRequestType.Recipient)
 426   2          {
 427   3            case USB_SETUP_RECIPIENT_DEVICE:
 428   3              if (myUsbDevice.setup.wIndex == 0)
 429   3              {
 430   4        #if SLAB_USB_REMOTE_WAKEUP_ENABLED
                        // Remote wakeup feature status
                        if (myUsbDevice.remoteWakeupEnabled)
                        {
                          pStatus |= htole16(REMOTE_WAKEUP_ENABLED);
                        }
                #endif // SLAB_USB_REMOTE_WAKEUP_ENABLED
 437   4      
 438   4        #if SLAB_USB_IS_SELF_POWERED_CB
 439   4                // Current self/bus power status
 440   4                if (USBD_IsSelfPoweredCb())
 441   4                {
 442   5                  pStatus |= htole16(DEVICE_IS_SELFPOWERED);
 443   5                }
 444   4        #elif (SLAB_USB_BUS_POWERED == 0)
                        pStatus |= htole16(DEVICE_IS_SELFPOWERED);
                #endif // SLAB_USB_IS_SELF_POWERED_CB
 447   4      
 448   4                retVal = USB_STATUS_OK;
 449   4              }
 450   3              break;
 451   3      
 452   3            case USB_SETUP_RECIPIENT_INTERFACE:
 453   3              if (myUsbDevice.setup.wIndex < SLAB_USB_NUM_INTERFACES)
 454   3              {
 455   4                retVal = USB_STATUS_OK;
 456   4              }
 457   3              break;
 458   3      
 459   3      
 460   3            case USB_SETUP_RECIPIENT_ENDPOINT:
 461   3              // Device does not support halting endpoint 0, but do not give
 462   3              // an error as this is a valid request
 463   3              if (((myUsbDevice.setup.wIndex & ~USB_EP_DIR_IN) == 0)
 464   3                  && (myUsbDevice.state == USBD_STATE_ADDRESSED))
 465   3              {
 466   4                retVal = USB_STATUS_OK;
 467   4              }
 468   3              else if (myUsbDevice.state == USBD_STATE_CONFIGURED)
 469   3              {
 470   4                switch (myUsbDevice.setup.wIndex & 0xFF)
 471   4                {
 472   5        #if SLAB_USB_EP1OUT_USED
 473   5                  case (USB_EP_DIR_OUT | 1):
 474   5                    if (myUsbDevice.ep1out.state == D_EP_HALT)
 475   5                    {
 476   6                      pStatus = htole16(1);
 477   6                    }
 478   5                    retVal = USB_STATUS_OK;
 479   5                    break;
 480   5        #endif
 481   5        #if SLAB_USB_EP2OUT_USED
                          case (USB_EP_DIR_OUT | 2):
                            if (myUsbDevice.ep2out.state == D_EP_HALT)
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 9   

                            {
                              pStatus = htole16(1);
                            }
                            retVal = USB_STATUS_OK;
                            break;
                #endif
 490   5        #if SLAB_USB_EP3OUT_USED
                          case (USB_EP_DIR_OUT | 3):
                            if (myUsbDevice.ep3out.state == D_EP_HALT)
                            {
                              pStatus = htole16(1);
                            }
                            retVal = USB_STATUS_OK;
                            break;
                #endif
 499   5        #if SLAB_USB_EP1IN_USED
 500   5                  case (USB_EP_DIR_IN | 1):
 501   5                    if (myUsbDevice.ep1in.state == D_EP_HALT)
 502   5                    {
 503   6                      pStatus = htole16(1);
 504   6                    }
 505   5                    retVal = USB_STATUS_OK;
 506   5                    break;
 507   5        #endif
 508   5        #if SLAB_USB_EP2IN_USED
                          case (USB_EP_DIR_IN | 2):
                            if (myUsbDevice.ep2in.state == D_EP_HALT)
                            {
                              pStatus = htole16(1);
                            }
                            retVal = USB_STATUS_OK;
                            break;
                #endif
 517   5        #if SLAB_USB_EP3IN_USED
                          case (USB_EP_DIR_IN | 3):
                            if (myUsbDevice.ep3in.state == D_EP_HALT)
                            {
                              pStatus = htole16(1);
                            }
                            retVal = USB_STATUS_OK;
                            break;
                #endif
 526   5                }
 527   4              }
 528   3              break;
 529   3          }
 530   2      
 531   2          // If the command was valid, send the requested status.
 532   2          if (retVal == USB_STATUS_OK)
 533   2          {
 534   3            EP0_Write((SI_VARIABLE_SEGMENT_POINTER(, uint8_t, SI_SEG_GENERIC))&pStatus, 2);
 535   3          }
 536   2        }
 537   1      
 538   1        return retVal;
 539   1      }
 540          
 541          /***************************************************************************//**
 542           * @brief       Sets the Address
 543           * @return      Status of request (type @ref USB_Status_TypeDef)
 544           * @note        This function takes no parameters, but it uses the setup command
 545           *              stored in @ref myUsbDevice.setup.
 546           ******************************************************************************/
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 10  

 547          static USB_Status_TypeDef SetAddress(void)
 548          {
 549   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 550   1      
 551   1        if ((myUsbDevice.setup.wValue < 128)
 552   1            && (myUsbDevice.setup.wLength == 0)
 553   1            && (myUsbDevice.setup.bmRequestType.Recipient == USB_SETUP_RECIPIENT_DEVICE)
 554   1            && (myUsbDevice.setup.wIndex == 0))
 555   1        {
 556   2          // If the device is in the Default state and the address is non-zero, put
 557   2          // the device in the Addressed state.
 558   2          if (myUsbDevice.state == USBD_STATE_DEFAULT)
 559   2          {
 560   3            if (myUsbDevice.setup.wValue != 0)
 561   3            {
 562   4              USBD_SetUsbState(USBD_STATE_ADDRESSED);
 563   4            }
 564   3            retVal = USB_STATUS_OK;
 565   3          }
 566   2          // If the device is already addressed and the address is zero, put the
 567   2          // device in the Default state.
 568   2          else if (myUsbDevice.state == USBD_STATE_ADDRESSED)
 569   2          {
 570   3            if (myUsbDevice.setup.wValue == 0)
 571   3            {
 572   4              USBD_SetUsbState(USBD_STATE_DEFAULT);
 573   4            }
 574   3            retVal = USB_STATUS_OK;
 575   3          }
 576   2      
 577   2          // Set the new address if the request was valid.
 578   2          if (retVal == USB_STATUS_OK)
 579   2          {
 580   3            USB_SetAddress(myUsbDevice.setup.wValue);
 581   3          }
 582   2        }
 583   1      
 584   1        return retVal;
 585   1      }
 586          
 587          /***************************************************************************//**
 588           * @brief       Sets the Configuration
 589           * @return      Status of request (type @ref USB_Status_TypeDef)
 590           * @note        This function takes no parameters, but it uses the setup command
 591           *              stored in @ref myUsbDevice.setup.
 592           ******************************************************************************/
 593          static USB_Status_TypeDef SetConfiguration(void)
 594          {
 595   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 596   1      
 597   1        if (((myUsbDevice.setup.wValue >> 8) == 0)
 598   1            && (myUsbDevice.setup.bmRequestType.Recipient == USB_SETUP_RECIPIENT_DEVICE)
 599   1            && (myUsbDevice.setup.wLength == 0)
 600   1            && (myUsbDevice.setup.wIndex == 0))
 601   1        {
 602   2          // If the device is in the Addressed state and a valid Configuration value
 603   2          // was sent, enter the Configured state.
 604   2          if (myUsbDevice.state == USBD_STATE_ADDRESSED)
 605   2          {
 606   3            if ((myUsbDevice.setup.wValue == 0)
 607   3                || (myUsbDevice.setup.wValue == myUsbDevice.configDescriptor->bConfigurationValue))
 608   3            {
 609   4              myUsbDevice.configurationValue = myUsbDevice.setup.wValue;
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 11  

 610   4              if (myUsbDevice.setup.wValue == myUsbDevice.configDescriptor->bConfigurationValue)
 611   4              {
 612   5                USBD_ActivateAllEps(true);
 613   5                USBD_SetUsbState(USBD_STATE_CONFIGURED);
 614   5              }
 615   4              retVal = USB_STATUS_OK;
 616   4            }
 617   3          }
 618   2          // If the device is in the Configured state and Configuration zero is sent,
 619   2          // abort all transfer and enter the Addressed state.
 620   2          else if (myUsbDevice.state == USBD_STATE_CONFIGURED)
 621   2          {
 622   3            if ((myUsbDevice.setup.wValue == 0)
 623   3                || (myUsbDevice.setup.wValue == myUsbDevice.configDescriptor->bConfigurationValue))
 624   3            {
 625   4              myUsbDevice.configurationValue = myUsbDevice.setup.wValue;
 626   4              if (myUsbDevice.setup.wValue == 0)
 627   4              {
 628   5                USBD_SetUsbState(USBD_STATE_ADDRESSED);
 629   5                USBD_AbortAllTransfers();
 630   5              }
 631   4              else
 632   4              {
 633   5                // Reenable device endpoints, will reset data toggles
 634   5                USBD_ActivateAllEps(false);
 635   5              }
 636   4              retVal = USB_STATUS_OK;
 637   4            }
 638   3          }
 639   2        }
 640   1      
 641   1        return retVal;
 642   1      }
 643          
 644          /***************************************************************************//**
 645           * @brief       Sets the Remote Wakeup or Endpoint Halt Feature
 646           * @return      Status of request (type @ref USB_Status_TypeDef)
 647           * @note        This function takes no parameters, but it uses the setup command
 648           *              stored in @ref myUsbDevice.setup.
 649           ******************************************************************************/
 650          static USB_Status_TypeDef SetFeature(void)
 651          {
 652   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 653   1      
 654   1        if (myUsbDevice.setup.wLength == 0)
 655   1        {
 656   2          switch (myUsbDevice.setup.bmRequestType.Recipient)
 657   2          {
 658   3        #if SLAB_USB_REMOTE_WAKEUP_ENABLED
                    case USB_SETUP_RECIPIENT_DEVICE:
                      if ((myUsbDevice.setup.wIndex == 0)     // ITF no. 0
                          && (myUsbDevice.setup.wValue == USB_FEATURE_DEVICE_REMOTE_WAKEUP)
                          && (myUsbDevice.state == USBD_STATE_CONFIGURED))
                      {
                        myUsbDevice.remoteWakeupEnabled = true;
                        retVal = USB_STATUS_OK;
                      }
                      break;
                #endif // SLAB_USB_REMOTE_WAKEUP_ENABLED
 669   3            case USB_SETUP_RECIPIENT_ENDPOINT:
 670   3              // Device does not support halting endpoint 0, but do not return
 671   3              // an error as this is a valid request
 672   3              if (((myUsbDevice.setup.wIndex & ~USB_EP_DIR_IN) == 0)
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 12  

 673   3                  && (myUsbDevice.state >= USBD_STATE_ADDRESSED))
 674   3              {
 675   4                retVal = USB_STATUS_OK;
 676   4              }
 677   3              else if ((((myUsbDevice.setup.wIndex) & ~USB_SETUP_DIR_D2H) < SLAB_USB_NUM_EPS_USED)
 678   3                       && (myUsbDevice.setup.wValue == USB_FEATURE_ENDPOINT_HALT)
 679   3                       && (myUsbDevice.state == USBD_STATE_CONFIGURED))
 680   3              {
 681   4                retVal = USB_STATUS_OK;
 682   4                USB_SetIndex((myUsbDevice.setup.wIndex & 0xFF) & ~USB_SETUP_DIR_D2H);
 683   4      
 684   4                // Enable Stalls on the specified endpoint.
 685   4      #if (SLAB_USB_EP1IN_USED || SLAB_USB_EP2IN_USED || SLAB_USB_EP3IN_USED)
 686   4                if ((myUsbDevice.setup.wIndex & 0xFF) & USB_EP_DIR_IN)
 687   4                {
 688   5                  USB_EpnInStall();
 689   5                }
 690   4      #endif
 691   4      #if (SLAB_USB_EP1OUT_USED || SLAB_USB_EP2OUT_USED || SLAB_USB_EP3OUT_USED)
 692   4                if (((myUsbDevice.setup.wIndex & 0xFF) & USB_EP_DIR_IN) == 0)
 693   4                {
 694   5                  USB_EpnOutStall();
 695   5                }
 696   4      #endif
 697   4      
 698   4                // Put the specified endpoint in the Halted state.
 699   4                switch (myUsbDevice.setup.wIndex & 0xFF)
 700   4                {
 701   5        #if SLAB_USB_EP1OUT_USED
 702   5                  case (USB_EP_DIR_OUT | 1):
 703   5                    myUsbDevice.ep1out.state = D_EP_HALT;
 704   5                    break;
 705   5        #endif
 706   5        #if SLAB_USB_EP2OUT_USED
                          case (USB_EP_DIR_OUT | 2):
                            myUsbDevice.ep2out.state = D_EP_HALT;
                            break;
                #endif
 711   5        #if SLAB_USB_EP3OUT_USED
                          case (USB_EP_DIR_OUT | 3):
                            myUsbDevice.ep3out.state = D_EP_HALT;
                            break;
                #endif
 716   5        #if SLAB_USB_EP1IN_USED
 717   5                  case (USB_EP_DIR_IN | 1):
 718   5                    myUsbDevice.ep1in.state = D_EP_HALT;
 719   5                    break;
 720   5        #endif
 721   5        #if SLAB_USB_EP2IN_USED
                          case (USB_EP_DIR_IN | 2):
                            myUsbDevice.ep2in.state = D_EP_HALT;
                            break;
                #endif
 726   5        #if SLAB_USB_EP3IN_USED
                          case (USB_EP_DIR_IN | 3):
                            myUsbDevice.ep3in.state = D_EP_HALT;
                            break;
                #endif
 731   5                }
 732   4              }
 733   3          }
 734   2        }
 735   1      
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 13  

 736   1        return retVal;
 737   1      }
 738          
 739          /***************************************************************************//**
 740           * @brief       Sets the Interface and Alternate Interface (if supported)
 741           * @return      Status of request (type @ref USB_Status_TypeDef)
 742           * @note        This function takes no parameters, but it uses the setup command
 743           *              stored in @ref myUsbDevice.setup.
 744           ******************************************************************************/
 745          static USB_Status_TypeDef SetInterface(void)
 746          {
 747   1        USB_Status_TypeDef retVal = USB_STATUS_REQ_ERR;
 748   1        uint8_t interface = (uint8_t)myUsbDevice.setup.wIndex;
 749   1        uint8_t altSetting = (uint8_t)myUsbDevice.setup.wValue;
 750   1      
 751   1        if ((interface < SLAB_USB_NUM_INTERFACES)
 752   1            && (myUsbDevice.state == USBD_STATE_CONFIGURED)
 753   1            && (myUsbDevice.setup.wLength == 0)
 754   1      #if (SLAB_USB_SUPPORT_ALT_INTERFACES == 0)
 755   1            && (altSetting == 0)
 756   1      #endif
 757   1            && (myUsbDevice.setup.bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE))
 758   1        {
 759   2      #if (SLAB_USB_SUPPORT_ALT_INTERFACES)
                  if (USBD_SetInterfaceCb(interface, altSetting) == USB_STATUS_OK)
                  {
                    myUsbDevice.interfaceAltSetting[interface] = altSetting;
                    retVal = USB_STATUS_OK;
                  }
              #else
 766   2      #if (SLAB_USB_NUM_INTERFACES == 1)
 767   2          // Reset data toggles on EP's
 768   2          USBD_ActivateAllEps(false);
 769   2      #endif // ( SLAB_USB_NUM_INTERFACES == 1 )
 770   2          retVal = USB_STATUS_OK;
 771   2      #endif // ( SLAB_USB_SUPPORT_ALT_INTERFACES )
 772   2        }
 773   1      
 774   1        return retVal;
 775   1      }
 776          
 777          // -----------------------------------------------------------------------------
 778          // Utility Functions
 779          
 780          /***************************************************************************//**
 781           * @brief       Enables all endpoints for data transfers
 782           * @return      Status of request (type @ref USB_Status_TypeDef)
 783           * @note        This function takes no parameters, but it uses the setup command
 784           *              stored in @ref myUsbDevice.setup.
 785           ******************************************************************************/
 786          static void USBD_ActivateAllEps(bool forceIdle)
 787          {
 788   1        if (forceIdle == true)
 789   1        {
 790   2      #if SLAB_USB_EP1IN_USED
 791   2          myUsbDevice.ep1in.state = D_EP_IDLE;
 792   2      #endif
 793   2      #if SLAB_USB_EP2IN_USED
                  myUsbDevice.ep2in.state = D_EP_IDLE;
              #endif
 796   2      #if SLAB_USB_EP3IN_USED
                  myUsbDevice.ep3in.state = D_EP_IDLE;
              #endif
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 14  

 799   2      #if SLAB_USB_EP1OUT_USED
 800   2          myUsbDevice.ep1out.state = D_EP_IDLE;
 801   2      #endif
 802   2      #if SLAB_USB_EP2OUT_USED
                  myUsbDevice.ep2out.state = D_EP_IDLE;
              #endif
 805   2      #if SLAB_USB_EP3OUT_USED
                  myUsbDevice.ep3out.state = D_EP_IDLE;
              #endif
 808   2        }
 809   1      
 810   1      #if SLAB_USB_EP1IN_USED
 811   1        USB_ActivateEp(1,                                                   // ep
 812   1                       SLAB_USB_EP1IN_MAX_PACKET_SIZE,                      // packetSize
 813   1                       1,                                                   // inDir
 814   1                       SLAB_USB_EP1OUT_USED,                                // splitMode
 815   1                       0);                                                  // isoMod
 816   1      #endif // SLAB_USB_EP1IN_USED
 817   1      #if SLAB_USB_EP2IN_USED
                USB_ActivateEp(2,                                                   // ep
                               SLAB_USB_EP2IN_MAX_PACKET_SIZE,                      // packetSize
                               1,                                                   // inDir
                               SLAB_USB_EP2OUT_USED,                                // splitMode
                               0);                                                  // isoMod
              #endif // SLAB_USB_EP2IN_USED
 824   1      #if SLAB_USB_EP3IN_USED
                USB_ActivateEp(3,                                                   // ep
                               SLAB_USB_EP3IN_MAX_PACKET_SIZE,                      // packetSize
                               1,                                                   // inDir
                               SLAB_USB_EP3OUT_USED,                                // splitMode
                               (SLAB_USB_EP3IN_TRANSFER_TYPE == USB_EPTYPE_ISOC));  // isoMod
              #endif // SLAB_USB_EP3IN_USED
 831   1      #if SLAB_USB_EP1OUT_USED
 832   1        USB_ActivateEp(1,                                                   // ep
 833   1                       SLAB_USB_EP1OUT_MAX_PACKET_SIZE,                     // packetSize
 834   1                       0,                                                   // inDir
 835   1                       SLAB_USB_EP1IN_USED,                                 // splitMode
 836   1                       0);                                                  // isoMod
 837   1      #endif // SLAB_USB_EP1OUT_USED
 838   1      #if SLAB_USB_EP2OUT_USED
                USB_ActivateEp(2,                                                   // ep
                               SLAB_USB_EP2OUT_MAX_PACKET_SIZE,                     // packetSize
                               0,                                                   // inDir
                               SLAB_USB_EP2IN_USED,                                 // splitMode
                               0);                                                  // isoMod
              #endif // SLAB_USB_EP2OUT_USED
 845   1      #if SLAB_USB_EP3OUT_USED
                USB_ActivateEp(3,                                                   // ep
                               SLAB_USB_EP3OUT_MAX_PACKET_SIZE,                     // packetSize
                               0,                                                   // inDir
                               SLAB_USB_EP3IN_USED,                                 // splitMode
                               (SLAB_USB_EP3OUT_TRANSFER_TYPE == USB_EPTYPE_ISOC)); // isoMod
              #endif // SLAB_USB_EP1OUT_USED
 852   1      }
 853          
 854          /***************************************************************************//**
 855           * @brief       Sets up an Endpoint 0 Write
 856           * @param       dat
 857           *              Data to transmit on Endpoint 0
 858           * @param       numBytes
 859           *              Number of bytes to transmit on Endpoint 0
 860           ******************************************************************************/
 861          static void EP0_Write(SI_VARIABLE_SEGMENT_POINTER(dat, uint8_t, SI_SEG_GENERIC), uint16_t numBytes)
C51 COMPILER V9.60.0.0   EFM8_USBDCH9                                                      04/23/2021 07:39:26 PAGE 15  

 862          {
 863   1        if (myUsbDevice.ep0.state == D_EP_IDLE)
 864   1        {
 865   2          myUsbDevice.ep0.buf = dat;
 866   2          myUsbDevice.ep0.remaining = numBytes;
 867   2          myUsbDevice.ep0.state = D_EP_TRANSMITTING;
 868   2          myUsbDevice.ep0.misc.c = 0;
 869   2      
 870   2          // Determine if we need to terminate Setup Data Phase with a ZLP.
 871   2          if (((numBytes % USB_EP0_SIZE) == 0)
 872   2              && (myUsbDevice.setup.wLength != numBytes))
 873   2          {
 874   3            myUsbDevice.ep0.misc.bits.transmitZlp = true;
 875   3          }
 876   2        }
 877   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1465    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
